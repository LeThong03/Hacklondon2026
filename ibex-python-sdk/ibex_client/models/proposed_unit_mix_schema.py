# coding: utf-8

"""
    Ibex Enterprise API

    Comprehensive API for accessing UK planning application data. Provides powerful search capabilities with geographic filtering and detailed application information.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt
from typing import Any, ClassVar, Dict, List, Optional
from ibex_client.models.unit_breakdown_item_schema import UnitBreakdownItemSchema
from typing import Optional, Set
from typing_extensions import Self

class ProposedUnitMixSchema(BaseModel):
    """
    Residential unit breakdown from extracted application forms
    """ # noqa: E501
    total_existing_residential_units: Optional[StrictInt] = None
    total_proposed_residential_units: Optional[StrictInt] = None
    proposed_1_bed_units: Optional[StrictInt] = None
    proposed_2_bed_units: Optional[StrictInt] = None
    proposed_3_bed_units: Optional[StrictInt] = None
    proposed_4_plus_bed_units: Optional[StrictInt] = None
    affordable_housing_units: Optional[StrictInt] = None
    proposed_terraced_count: Optional[StrictInt] = Field(default=None, description="Number of proposed terraced homes")
    proposed_semi_count: Optional[StrictInt] = Field(default=None, description="Number of proposed semi-detached homes")
    proposed_detached_count: Optional[StrictInt] = Field(default=None, description="Number of proposed detached homes")
    proposed_flat_count: Optional[StrictInt] = Field(default=None, description="Number of proposed flats/apartments")
    proposed_market_units: Optional[StrictInt] = Field(default=None, description="Number of market rate units")
    proposed_affordable_units: Optional[StrictInt] = Field(default=None, description="Number of affordable housing units (all types)")
    proposed_shared_ownership_units: Optional[StrictInt] = Field(default=None, description="Number of shared ownership units")
    proposed_social_rent_units: Optional[StrictInt] = Field(default=None, description="Number of social rent units")
    units_to_be_added: Optional[List[UnitBreakdownItemSchema]] = Field(default=None, description="Detailed breakdown of units to be added")
    units_to_be_lost: Optional[List[UnitBreakdownItemSchema]] = Field(default=None, description="Detailed breakdown of units to be lost/demolished")
    __properties: ClassVar[List[str]] = ["total_existing_residential_units", "total_proposed_residential_units", "proposed_1_bed_units", "proposed_2_bed_units", "proposed_3_bed_units", "proposed_4_plus_bed_units", "affordable_housing_units", "proposed_terraced_count", "proposed_semi_count", "proposed_detached_count", "proposed_flat_count", "proposed_market_units", "proposed_affordable_units", "proposed_shared_ownership_units", "proposed_social_rent_units", "units_to_be_added", "units_to_be_lost"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ProposedUnitMixSchema from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in units_to_be_added (list)
        _items = []
        if self.units_to_be_added:
            for _item_units_to_be_added in self.units_to_be_added:
                if _item_units_to_be_added:
                    _items.append(_item_units_to_be_added.to_dict())
            _dict['units_to_be_added'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in units_to_be_lost (list)
        _items = []
        if self.units_to_be_lost:
            for _item_units_to_be_lost in self.units_to_be_lost:
                if _item_units_to_be_lost:
                    _items.append(_item_units_to_be_lost.to_dict())
            _dict['units_to_be_lost'] = _items
        # set to None if total_existing_residential_units (nullable) is None
        # and model_fields_set contains the field
        if self.total_existing_residential_units is None and "total_existing_residential_units" in self.model_fields_set:
            _dict['total_existing_residential_units'] = None

        # set to None if total_proposed_residential_units (nullable) is None
        # and model_fields_set contains the field
        if self.total_proposed_residential_units is None and "total_proposed_residential_units" in self.model_fields_set:
            _dict['total_proposed_residential_units'] = None

        # set to None if proposed_1_bed_units (nullable) is None
        # and model_fields_set contains the field
        if self.proposed_1_bed_units is None and "proposed_1_bed_units" in self.model_fields_set:
            _dict['proposed_1_bed_units'] = None

        # set to None if proposed_2_bed_units (nullable) is None
        # and model_fields_set contains the field
        if self.proposed_2_bed_units is None and "proposed_2_bed_units" in self.model_fields_set:
            _dict['proposed_2_bed_units'] = None

        # set to None if proposed_3_bed_units (nullable) is None
        # and model_fields_set contains the field
        if self.proposed_3_bed_units is None and "proposed_3_bed_units" in self.model_fields_set:
            _dict['proposed_3_bed_units'] = None

        # set to None if proposed_4_plus_bed_units (nullable) is None
        # and model_fields_set contains the field
        if self.proposed_4_plus_bed_units is None and "proposed_4_plus_bed_units" in self.model_fields_set:
            _dict['proposed_4_plus_bed_units'] = None

        # set to None if affordable_housing_units (nullable) is None
        # and model_fields_set contains the field
        if self.affordable_housing_units is None and "affordable_housing_units" in self.model_fields_set:
            _dict['affordable_housing_units'] = None

        # set to None if proposed_terraced_count (nullable) is None
        # and model_fields_set contains the field
        if self.proposed_terraced_count is None and "proposed_terraced_count" in self.model_fields_set:
            _dict['proposed_terraced_count'] = None

        # set to None if proposed_semi_count (nullable) is None
        # and model_fields_set contains the field
        if self.proposed_semi_count is None and "proposed_semi_count" in self.model_fields_set:
            _dict['proposed_semi_count'] = None

        # set to None if proposed_detached_count (nullable) is None
        # and model_fields_set contains the field
        if self.proposed_detached_count is None and "proposed_detached_count" in self.model_fields_set:
            _dict['proposed_detached_count'] = None

        # set to None if proposed_flat_count (nullable) is None
        # and model_fields_set contains the field
        if self.proposed_flat_count is None and "proposed_flat_count" in self.model_fields_set:
            _dict['proposed_flat_count'] = None

        # set to None if proposed_market_units (nullable) is None
        # and model_fields_set contains the field
        if self.proposed_market_units is None and "proposed_market_units" in self.model_fields_set:
            _dict['proposed_market_units'] = None

        # set to None if proposed_affordable_units (nullable) is None
        # and model_fields_set contains the field
        if self.proposed_affordable_units is None and "proposed_affordable_units" in self.model_fields_set:
            _dict['proposed_affordable_units'] = None

        # set to None if proposed_shared_ownership_units (nullable) is None
        # and model_fields_set contains the field
        if self.proposed_shared_ownership_units is None and "proposed_shared_ownership_units" in self.model_fields_set:
            _dict['proposed_shared_ownership_units'] = None

        # set to None if proposed_social_rent_units (nullable) is None
        # and model_fields_set contains the field
        if self.proposed_social_rent_units is None and "proposed_social_rent_units" in self.model_fields_set:
            _dict['proposed_social_rent_units'] = None

        # set to None if units_to_be_added (nullable) is None
        # and model_fields_set contains the field
        if self.units_to_be_added is None and "units_to_be_added" in self.model_fields_set:
            _dict['units_to_be_added'] = None

        # set to None if units_to_be_lost (nullable) is None
        # and model_fields_set contains the field
        if self.units_to_be_lost is None and "units_to_be_lost" in self.model_fields_set:
            _dict['units_to_be_lost'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ProposedUnitMixSchema from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "total_existing_residential_units": obj.get("total_existing_residential_units"),
            "total_proposed_residential_units": obj.get("total_proposed_residential_units"),
            "proposed_1_bed_units": obj.get("proposed_1_bed_units"),
            "proposed_2_bed_units": obj.get("proposed_2_bed_units"),
            "proposed_3_bed_units": obj.get("proposed_3_bed_units"),
            "proposed_4_plus_bed_units": obj.get("proposed_4_plus_bed_units"),
            "affordable_housing_units": obj.get("affordable_housing_units"),
            "proposed_terraced_count": obj.get("proposed_terraced_count"),
            "proposed_semi_count": obj.get("proposed_semi_count"),
            "proposed_detached_count": obj.get("proposed_detached_count"),
            "proposed_flat_count": obj.get("proposed_flat_count"),
            "proposed_market_units": obj.get("proposed_market_units"),
            "proposed_affordable_units": obj.get("proposed_affordable_units"),
            "proposed_shared_ownership_units": obj.get("proposed_shared_ownership_units"),
            "proposed_social_rent_units": obj.get("proposed_social_rent_units"),
            "units_to_be_added": [UnitBreakdownItemSchema.from_dict(_item) for _item in obj["units_to_be_added"]] if obj.get("units_to_be_added") is not None else None,
            "units_to_be_lost": [UnitBreakdownItemSchema.from_dict(_item) for _item in obj["units_to_be_lost"]] if obj.get("units_to_be_lost") is not None else None
        })
        return _obj


